---
title: "Error handling in R with tryCatchLog<br>(catch, log, post-mortem analysis)"
author: Jürgen Altfeld (TODO (c) and License)
date: Dec. 2016
description: some text to be displayed?
output:
        revealjs::revealjs_presentation:
          self_contained: true
#          self_contained: false
#          reveal_plugins: ["notes", "search", "zoom"]
          theme: white
          highlight: tango
          center: false
          height: 1024
          width: 1920
          margin: 0.1
          minScale: 0.2
          maxScale: 1.0
          reveal_options:
            slideNumber: true
#            previewLinks: true
---



## License (GPL-3)

![gplv3 logo](gplv3-127x51.png)

Copyright (C) 2016 Juergen Altfeld (R@altfeld-im.de)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received [a copy of the GNU General Public License](LICENSE)
along with this program.  If not, see <http://www.gnu.org/licenses/>.



<style type="text/css">

  .reveal .slides .title {
    font-size: 125%;
    margin-bottom: 150px;
    color: black;
    text-transform: none;
  }

  .reveal .slides .author {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slides .date {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slide h1 {
    font-size: 40px;
    text-align: left;
    color: blue;
    text-transform: none;
  }

  .reveal .slide h2 {
    font-size: 30px;
    text-align: left;
    color: blue;
  }

  .reveal .slide h3 {
    font-size: 20px;
    text-align: left;
    color: blue;
  }

  .reveal section p {
    text-align: left;
    font-size: 70%;
  }

  .reveal section ul  {
    list-style-type: square;
    display: block;
    font-size: 70%;
  }

  .reveal section ol  {
    display: block;
    font-size: 70%;
  }

  .reveal section code {
    font-size: 90%;
    font-familie: Courier
  }

  .reveal pre {
    width: 98%;
  }

</style>



## Table of contents

[Condition handling in standard R](#/condition-handling-in-standard-r)

TODO

[Open printable version of these slides](?print-pdf)



# Introduction into conditions in standard R

## What is a condition?

The execution of an R script can be interrupted to signal special states (*conditions*).

Examples:

- errors
- warnings
- messages
- user interrupts (by hitting CTRL + C/BRK or ESC)



## Condition examples

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE, error = TRUE)  # render R errors as output instead of stopping to knit
```

An error condition:
```{r, error = TRUE}
log("text")   # throws an error
```


A warning condition:
```{r, results='hold'}
log(-1)                # throws a warning
```



# Throw your own conditions

Note: This text will never be shown due to a "limitation by design" of pandoc:

http://stackoverflow.com/a/31778080/4468078



## Error

Based on a "condition" (expression) to recognize an invalid state:
```{r, error = TRUE}
if (1 != 2)
  stop("something is wrong")
```

Or shorter (but without a message text):
```{r, error = TRUE}
stopifnot(1 == 2)
```



## Warning

```{r}
warning("bad weather today, don't forget your umbrella")
```

## Message

```{r}
message("good morning")
```



# Handling conditions in R

Scroll down for examples...

## Unhandled errors stop R

By default R will stop the execution if an error occurs:
```{r, error = TRUE, eval = TRUE}
options(error = NULL)  # switch to default behaviour of R
{
  log("not a number")
  print("R does stop due to an error and never executes this line")
}
```
Note that the output does **not** show the `print` result since the execution stops in case of an error.



## Use `try` to ignore errors

With the `try` function you can handle errors to continue the execution (by ignoring the error):
```{r, collapse = FALSE, eval = TRUE}
{
  try(log("not a number"))
  print("errors can't stop me")
}
```



## Use `tryCatch` to handle errors

With `tryCatch` you can handle errors as you want:
```{r}
an.error.occured <- FALSE
tryCatch( { res <- log("not a number"); print(res) }
          , error = function(e) {an.error.occured <<- TRUE})
print(an.error.occured)
```

Note: If you use an error handler function the error is not shown anymore and the execution continues after
the `tryCatch` statement.



## `tryCatch` can handle all conditions 1/2

... not only errors. Just use the condition name as parameter to handle conditions of this type, e. g. a warning:

```{r}
tryCatch( { res <- log(-1); print("Done") }
          , warning = function(w) { print("Hey, a warning") })
```


## `tryCatch` can handle all conditions 1/2

You can use `error`, `warning`, `message` or `interrupt` as parameter name to assign a handler for these "standard" conditions:

```{r}
last.message <- NULL
tryCatch( { message("please handle me"); print("Done") }
          , message = function(m) { last.message <<- m })
print(last.message$message)
```



## User defined conditions

You can even define your own user-defined condition classes, but
there is no built in function to generate a new object of class condition.
So do it yourself:*

```{r}
condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure( class = c(subclass, "condition"),
             list(message = message, call = call, ...))
}

tryCatch( { wc <- condition("work.condition", "after work party")
            signalCondition(wc); print("Done") }
          , work.condition = function(c) { print(c$message) })
```

User-defined condition classes are only required if you want to implement a specific recovery strategy for
this condition. This is out of scope of this presentation.

*) Source: <http://adv-r.had.co.nz/beyond-exception-handling.html>



## But `tryCatch` is not perfect

Have you discovered the problem in the previous examples?

See the next slides for the answer!


# The drawbacks of `tryCatch`

## 1. Handling a condition stops the execution 1/2

If you catch a warning (or another non-error condition) with `tryCatch` then R does

1. abort the execution of code that throwed the condition,
1. executes the handler function and
1. then continues the execution with the next command after the `tryCatch` command:

```{r, echo=FALSE}
# dummy code to avoid a "missing function" error in the next code junk
write.to.log <- function(msg) { invisible() }
```


```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
tryCatch(f(), warning = function(w) { write.to.log(w) })
print("Done")
```

Observe: *Hello old world* is never printed! But normally you just want to log warnings without stopping the execution of the function `f()`.
It does **not** resume with the next command after the code that raised (throwed) the condition!



## 1. Handling a condition stops the execution 2/2

Compare: Calling the function without `tryCatch` does not stop the
execution of the function `f()`:

```{r}
{ # Execute as one block of code to show the output at the end only
  f <- function() {
    warning("deprecated function called")
    print("Hello old world")
  }
  f()
  print("Done")
}
```



## 2. Handling errors unrolls the stack trace 1/2

If you do **not catch an error** you can get the complete function call stack using `traceback`
which helps you to identify the code that throwed the error:

```{r, error = TRUE, eval = FALSE}
options(error=function() traceback(2)) # hack from: http://stackoverflow.com/a/13119318/4468078
f <- function() {
  log("not a number")
  print("Hello world")
}
f()
```

```{r, eval = FALSE}
Error in log("not a number") : 
  non-numeric argument to mathematical function
6: (function () 
   traceback(2))() at f.R#3
5: f() at f.R#6
...
1: source("f.R")
```



## 2. Handling errors unrolls the stack trace 2/2

But if you handle the error:

```{r, error = TRUE, eval = FALSE}
f <- function() {
  log("not a number")
  print("Hello world")
}
tryCatch(f(), error = function(e) { traceback() })
```

```{r, eval = FALSE}
8: value[[3L]](cond)
7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
6: tryCatchList(expr, classes, parentenv, handlers)
5: tryCatch(f(), error = function(e) {
       traceback(2)
   }) at f.R#5
...
1: source("f.R")
```

The call stack ends basically with the `tryCatch` call but does **not** show you the code in `f()`
where the error was thrown.


## Summary: The drawbacks of `tryCatch`

**How can you find out the exact reason for the error**

- without a full stack trace?
- if logging of warnings and messages is not possible without canceling
  the execution and resuming after `tryCatch`?



# Workaround 1: Interactive debugging

## Interactive debugging

You can run and debug your R script interactively in the *RGui* or [RStudio](https://www.rstudio.com/products/rstudio/).

For more details on interactive debugging see `?debug`.

**Note: Interactive debugging is out of scope of this presentation.**



## Limitations of interactive debugging

Interactive debugging is very difficult in case of

- errors that are not (easily) reproducible.
- long running code that produces an error at the end
- batch jobs running on a server



# Workaround 2: Use `withCallingHandlers` with `tryCatch`


## How `withCallingHandlers` works

`withCallingHandlers` works similar to `tryCatch` but

1. remembers the call stack down to the point where the condition was signaled
2. resumes the execution after the point where the condition was signaled

```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls()) })
print("Done")
```

`sys.calls` within `withCallingHandlers` returns the full call stack.



## `withCallingHandlers` with restarts

Restarts are used to recover from conditions using a predefined behaviour:

```{r, results = 'hold'}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls())
                                                 invokeRestart("muffleWarning")})
print("Done")
```

`invokeRestart("muffleWarning")` has a simple recovery strategy: "Suppress the warning".

It removes the warning (so it cannot be handled anymore at higher function call levels)
and resumes the execution.



## Differences between `withCallingHandlers` and `tryCatch`

- `withCallingHandlers` remembers the call stack
- `tryCatch` unwinds the stack to the `tryCatch` call
- `withCallingHandlers` resumes execution in case of non-error conditions
- `tryCatch` breaks and continues after the `tryCatch` command

TODO: A table would be clearer!



## Combine `withCallingHandlers` with `tryCatch`

Requirements for better condition handling in R:

- Log all conditions on console or in file
- resume execution after warnings and messages
- and continue after the handling function in case of an error

Solution:

- handle all conditions in `withCallingHandlers` to log them with the full stack trace
- to resume after a non-error condition invoke a restart in `withCallingHandlers`
- handle only errors in `tryCatch` to recover from the error and continue execution after `tryCatch`



## Implementation template

An improved "error handler" in R looks similar to this code pattern:
```{r, results='hold'}
f <- function() {
  warning("deprecated function called")
  print("A warning cannot stop me")
  log("not a number")
  print("Hello old world")
}

tryCatch(withCallingHandlers(f(), error = function(e)   { write.to.log(sys.calls()) }
                                , warning = function(w) { write.to.log(sys.calls())
                                                          invokeRestart("muffleWarning") })
         , error = function(e) { print("recovered from error") })
print("Done")
```

**This is how `tryCatchLog` works internally!**



## Usability?

**Do you really want to use that much code in your R script at every place
where you have to catch errors and conditions?**

See the the next slides on how the package `tryCatchLog` could make your life easier!



# Solution: The `tryCatchLog` package

## `tryLog` with an error

```{r, results = 'hide', message = FALSE, echo = FALSE}
library(tryCatchLog)   # load the package to avoid startup messages in the results later
```

Errors are logged but the execution continues after the `tryLog` call:

```{r, eval = FALSE, warning=F}
library(tryCatchLog)
f <- function(value) {
  print("begin")
  log(value)            # negative number -> warning; string -> error
  print("end")
}
tryLog(f("not a number"))  
print("Errors don't stop me!")
```

```{r, eval = FALSE}
## [1] "begin"
## ERROR [2016-12-06 21:44:21] non-numeric argument to mathematical function
## Compact call stack:
##   1 test.R#7: tryLog(f("not a number"))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .handleSimpleError(function (e) 
## ...
## [1] "Errors don't stop me!"
```



## `tryLog` with a warning



`tryLog` traps conditions and log them onto console or into a file (depending of the settings of
the logging framework `futile.logger` that is used internally):

```{r, eval = FALSE, warning=F}
library(tryCatchLog)
f <- function(value) {
  print("begin")
  log(value)            # negative number -> warning; string -> error
  print("end")
}
tryLog(f(-1))  
```

```{r eval = FALSE}
## [1] "begin"
## WARN [2016-12-06 21:33:41] NaNs produced
## Compact call stack:
##   1 test.R#7: tryLog(f(-1))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .signalSimpleWarning("NaNs produced", quote(log(value)))
...
## [1] "end"
```



## `tryCatchLog` to recover from errors

Use `tryCatchLog` to also establish an error handler:

```{r, eval = FALSE}
library(tryCatchLog)

tryCatchLog(read.csv("server.log"),
            error = function(e) { send.email("admin@home.de", e)
})
```

```{r eval = FALSE}
## ERROR [2016-12-06 22:13:05] cannot open the connection
## Compact call stack:
##   1 test.R#3: tryCatchLog(read.csv("server.log"), error = function(e) {
##   2 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
...
```

**Note:** `send.email` is a dummy function for demonstration purposes!



## Change logging behaviour

To log to a file instead of the console or to change the logging level you call the usual `futile.logger` functions:

```{r eval = FALSE}
  library(futile.logger)
  flog.appender(appender.file("app.log"))
  flog.threshold(ERROR)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL
  try(log(-1))             # the warning will not be logged!
```

For more details about `futile.logger` see:

https://cran.r-project.org/package=futile.logger



# Post-mortem analysis



## From interactive debugging...

Interactive debugging is very difficult in case of

- errors that are not (easily) reproducible.
- long running code that produces an error at the end
- batch jobs running on a server



## ... to post-mortem analysis

**Post-mortem analysis**: In case of an error create a dump file with all variables of the global environment (workspace)
and all environments of each called function (via `dump.frames`) so that you can

- load the dump file into a new R session after the script has stopped the execution ("post-mortem") and
- examine the call stack and variable values ("analysis")

to find out the reason for the error.



## Create a dump file with `tryCatchLog`

`tryCatchLog` supports post-mortem analysis by creating dump files in case of errors:

```{r eval = FALSE}
library(tryCatchLog)
f <- function(value) {
  log(value)
}
a <- "100"
tryLog(f(a), dump.errors.to.file = TRUE)
```

```{r eval = FALSE}
ERROR [2016-12-12 22:29:52] non-numeric argument to mathematical function
Call stack environments dumped into file: dump_20161212_222952.rda
Compact call stack:
  1 source("~/R_trainings/tryCatchLog/src/test.R")
  2 test.R#6: tryLog(f(a), dump.errors.to.file = TRUE)
  3 tryCatchLog.R#348: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
  4 tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
  5 test.R#3: .handleSimpleError(function (e)
  ...
```



## Start post-mortem debugging

Open a new R session and start the post-mortem analysis of the error:

```{r eval = FALSE}
load("dump_20161212_222952.rda")    # load the dump into the global environment
debugger(last.dump)                 # start the post-mortem analysis
```

```{r eval = FALSE}
Message:  non-numeric argument to mathematical functionAvailable environments had calls:
1: source("test.R")
...
5: test.R#6: tryLog(f(a), dump.errors.to.file = TRUE)
6: tryCatchLog.R#348: tryCatchLog(expr = expr, dump.errors.to.file = dump.erro
7: tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
...
12: f(a)
13: test.R#3: .handleSimpleError(function (e) 
14: h(simpleError(msg, call))

Enter an environment number, or 0 to exit  
Selection: <Cursor is waiting for your input here>
```

Function call 13 shows: The error was thrown in the file `test.R` at line #3: `log(value)`



## Post-mortem debugging: Examine an environment

Switch into the environment of the function call 12 in which the error occured.

The environment of function call 12 contains all variables visible within the function:

```{r eval = FALSE}
Enter an environment number, or 0 to exit  
Selection: 12
Browsing in the environment with call:
   f(a)
Called from: debugger.look(ind)
Browse[1]> ls()
[1] "value"
Browse[1]> value
[1] "100"
Browse[1]> typeof(value)
[1] "character"
Browse[1]> 
```

By looking at the value and data type of the variable `value` it is easy to identify the reason for error.

*You can exit the debugger with "Q" (or "f" followed by "0") now.*



## TODO:  tryCatchLog functions overview

- tryCatchLog
- tryLog
- options



## TODO: Best practices

- Options zum gezielten temporären Aktivieren von Funktionalitäten
- Anwendungs-Szenarios interaktiv (mit/ohne Benutzer-Interaktion) vs. Batch


## TODO Summary + advantages

Probleme bei klassischen error handling:

- sys.calls enthält keine source code references -> limitedLabels
- sys.calls (genau wie traceback) enthält auch viele R-interne Funktionsaufrufe,
  die für die Fehlersuche nicht hilfreich sind -> gilt aber auch für tryCatchLog!
- Kombi aus withCallingHandlers und tryCatch ist umständlich und lang

Vorteile von tryCatchLog

+ source code references
+ compact call stack (if available) 
+ Top-Feature: post-mortem analysis!
+ also logs conditions from used packages

