---
title: Error handling in R with tryCatchLog:<br>Catch, log and post-mortem analysis
author: Jürgen Altfeld
date: Dec. 2016<br><br><br><p style="font-size:0.5em">These slides have been created with RMarkdown and the package <a href="https://github.com/rstudio/revealjs">revealjs</a><p>
description: some text to be displayed?
output:
        revealjs::revealjs_presentation:
          self_contained: true
# chalkboard added Nov. 2016: https://github.com/rstudio/revealjs/issues/42 but this requires "selfcontained" = false !!!
#          self_contained: false
#          reveal_plugins: ["notes", "search", "zoom", "chalkboard"]
          theme: white
          highlight: tango
          center: false
          height: 1024
          width: 1920
          margin: 0.1
          minScale: 0.2
          maxScale: 1.0
          reveal_options:
            slideNumber: true
#            previewLinks: true
---



## License (GPL-3)

![gplv3 logo](gplv3-127x51.png)

Copyright (C) 2016 Juergen Altfeld (R@altfeld-im.de)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received [a copy of the GNU General Public License](LICENSE)
along with this program.  If not, see <http://www.gnu.org/licenses/>.


<!-- !!! NEVER EVER ADD HTML COMMENTS INSIDE OF THE STYLE TAG SINCE IT BREAKS THE STYLE SOMETIMES !!! -->

<style type="text/css">

  .reveal .slides .title {
    font-size: 125%;
    margin-bottom: 150px;
    color: black;
    text-transform: none;
  }

  .reveal .slides .author {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slides .date {
    font-size: 75%;
    color: grey;
    text-transform: none;
  }

  .reveal .slide h1 {
    font-size: 40px;
    text-align: left;
    color: blue;
    text-transform: none;
  }

  .reveal .slide h2 {
    font-size: 30px;
    text-align: left;
    color: blue;
  }

  .reveal .slide h3 {
    font-size: 20px;
    text-align: left;
    color: blue;
  }


  .reveal section > p {
    text-align: left;
    font-size: 70%;
  }

  .reveal section ul  {
    list-style-type: square;
    display: block;
    font-size: 70%;
  }

  .reveal section ol  {
    display: block;
    font-size: 70%;
  }
  
  .reveal section code {
    font-size: 90%;
    font-familie: Courier
  }

  .reveal pre {
    width: 98%;
  }

</style>



## Table of contents

[Condition handling in standard R](#/condition-handling-in-standard-r)

TODO

[Open printable version of these slides](?print-pdf)



# Introduction into conditions in standard R

## What is a condition?

The execution of an R script can be interrupted to signal special states (*conditions*).

Examples:

- errors
- warnings
- messages
- user interrupts (by hitting CTRL + C/BRK or ESC)



## Condition examples

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = TRUE, error = TRUE)  # render R errors as output instead of stopping to knit
```

An error condition:
```{r, error = TRUE}
log("text")   # throws an error
```


A warning condition:
```{r, results='hold'}
log(-1)                # throws a warning
```



# Throw your own conditions

Note: This text will never be shown due to a "limitation by design" of pandoc:

http://stackoverflow.com/a/31778080/4468078



## Error

Based on a "condition" (expression) to recognize an invalid state:
```{r, error = TRUE}
if (1 != 2)
  stop("something is wrong")
```

Or shorter (but without a message text):
```{r, error = TRUE}
stopifnot(1 == 2)
```



## Warning

```{r}
warning("bad weather today, don't forget your umbrella")
```

## Message

```{r}
message("good morning")
```



# Handling conditions in R

Scroll down for examples...

## Unhandled errors stop R

By default R will stop the execution if an error occurs:
```{r, error = TRUE, eval = TRUE}
options(error = NULL)  # switch to default behaviour of R
{
  log("not a number")
  print("R does stop due to an error and never executes this line")
}
```
Note that the output does **not** show the `print` result since the execution stops in case of an error.



## Use `try` to ignore errors

With the `try` function you can handle errors to continue the execution (by ignoring the error):
```{r, collapse = FALSE, eval = TRUE}
{
  try(log("not a number"))
  print("errors can't stop me")
}
```



## Use `tryCatch` to handle errors

With `tryCatch` you can handle errors as you want:
```{r}
an.error.occured <- FALSE
tryCatch( { res <- log("not a number"); print(res) }
          , error = function(e) {an.error.occured <<- TRUE})
print(an.error.occured)
```

Note: If you use an error handler function the error is not shown anymore and the execution continues after
the `tryCatch` statement.



## `tryCatch` can handle all conditions 1/2

... not only errors. Just use the condition name as parameter to handle conditions of this type, e. g. a warning:

```{r}
tryCatch( { res <- log(-1); print("Done") }
          , warning = function(w) { print("Hey, a warning") })
```


## `tryCatch` can handle all conditions 1/2

You can use `error`, `warning`, `message` or `interrupt` as parameter name to assign a handler for these "standard" conditions:

```{r}
last.message <- NULL
tryCatch( { message("please handle me"); print("Done") }
          , message = function(m) { last.message <<- m })
print(last.message$message)
```



## User defined conditions

You can even define your own user-defined condition classes, but
there is no built in function to generate a new object of class condition.
So do it yourself:*

```{r}
condition <- function(subclass, message, call = sys.call(-1), ...) {
  structure( class = c(subclass, "condition"),
             list(message = message, call = call, ...))
}

tryCatch( { wc <- condition("work.condition", "after work party")
            signalCondition(wc); print("Done") }
          , work.condition = function(c) { print(c$message) })
```

User-defined condition classes are only required if you want to implement a specific recovery strategy for
this condition. This is out of scope of this presentation.

*) Source: <http://adv-r.had.co.nz/beyond-exception-handling.html>



## But `tryCatch` is not perfect

Have you discovered the problem in the previous examples?

See the next slides for the answer!


# The drawbacks of `tryCatch`

## 1. Handling a condition stops the execution 1/2

If you catch a warning (or another non-error condition) with `tryCatch` then R does

1. abort the execution of code that throwed the condition,
1. executes the handler function and
1. then continues the execution with the next command after the `tryCatch` command:

```{r, echo=FALSE}
# dummy code to avoid a "missing function" error in the next code junk
write.to.log <- function(msg) { invisible() }
```


```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
tryCatch(f(), warning = function(w) { write.to.log(w) })
print("Done")
```

Observe: *Hello old world* is never printed! But normally you just want to log warnings without stopping the execution of the function `f()`.
It does **not** resume with the next command after the code that raised (throwed) the condition!



## 1. Handling a condition stops the execution 2/2

Compare: Calling the function without `tryCatch` does not stop the
execution of the function `f()`:

```{r}
{ # Execute as one block of code to show the output at the end only
  f <- function() {
    warning("deprecated function called")
    print("Hello old world")
  }
  f()
  print("Done")
}
```



## 2. Handling errors unrolls the stack trace 1/2

If you do **not catch an error** you can get the complete function call stack using `traceback`
which helps you to identify the code that throwed the error:

```{r, error = TRUE, eval = FALSE}
options(error=function() traceback(2)) # hack from: http://stackoverflow.com/a/13119318/4468078
f <- function() {
  log("not a number")
  print("Hello world")
}
f()
```

```{r, eval = FALSE}
Error in log("not a number") : 
  non-numeric argument to mathematical function
6: (function () 
   traceback(2))() at f.R#3
5: f() at f.R#6
...
1: source("f.R")
```



## 2. Handling errors unrolls the stack trace 2/2

But if you handle the error:

```{r, error = TRUE, eval = FALSE}
f <- function() {
  log("not a number")
  print("Hello world")
}
tryCatch(f(), error = function(e) { traceback() })
```

```{r, eval = FALSE}
8: value[[3L]](cond)
7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
6: tryCatchList(expr, classes, parentenv, handlers)
5: tryCatch(f(), error = function(e) {
       traceback(2)
   }) at f.R#5
...
1: source("f.R")
```

The call stack ends basically with the `tryCatch` call but does **not** show you the code in `f()`
where the error was thrown.


## Summary: The drawbacks of `tryCatch`

**How can you find out the exact reason for the error**

- without a full stack trace?
- if logging of warnings and messages is not possible without canceling
  the execution and resuming after `tryCatch`?



# Workaround 1: Interactive debugging

## Interactive debugging

You can run and debug your R script interactively in the *RGui* or [RStudio](https://www.rstudio.com/products/rstudio/).

For more details on interactive debugging see `?debug`.

**Note: Interactive debugging is out of scope of this presentation.**



## Limitations of interactive debugging

Interactive debugging is very difficult in case of

- errors that are not (easily) reproducible.
- long running code that produces an error at the end
- batch jobs running on a server



# Workaround 2: Use `withCallingHandlers` with `tryCatch`


## How `withCallingHandlers` works

`withCallingHandlers` works similar to `tryCatch` but

1. remembers the call stack down to the point where the condition was signaled
2. resumes the execution after the point where the condition was signaled

```{r}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls()) })
print("Done")
```

`sys.calls` within `withCallingHandlers` returns the full call stack.



## `withCallingHandlers` with restarts

Restarts are used to recover from conditions using a predefined behaviour:

```{r, results = 'hold'}
f <- function() {
  warning("deprecated function called")
  print("Hello old world")
}
withCallingHandlers(f(), warning = function(w) { write.to.log(sys.calls())
                                                 invokeRestart("muffleWarning")})
print("Done")
```

`invokeRestart("muffleWarning")` has a simple recovery strategy: "Suppress the warning".

It removes the warning (so it cannot be handled anymore at higher function call levels)
and resumes the execution.



## Differences between `withCallingHandlers` and `tryCatch`

- `withCallingHandlers` remembers the call stack
- `tryCatch` unwinds the stack to the `tryCatch` call
- `withCallingHandlers` resumes execution in case of non-error conditions
- `tryCatch` breaks and continues after the `tryCatch` command

TODO: A table would be clearer!



## Combine `withCallingHandlers` with `tryCatch`

Requirements for better condition handling in R:

- Log all conditions on console or in file
- resume execution after warnings and messages
- and continue after the handling function in case of an error

Solution:

- handle all conditions in `withCallingHandlers` to log them with the full stack trace
- to resume after a non-error condition invoke a restart in `withCallingHandlers`
- handle only errors in `tryCatch` to recover from the error and continue execution after `tryCatch`



## Implementation template

An improved "error handler" in R looks similar to this code pattern:
```{r, results='hold'}
f <- function() {
  warning("deprecated function called")
  print("A warning cannot stop me")
  log("not a number")
  print("Hello old world")
}

tryCatch(withCallingHandlers(f(), error = function(e)   { write.to.log(sys.calls()) }
                                , warning = function(w) { write.to.log(sys.calls())
                                                          invokeRestart("muffleWarning") })
         , error = function(e) { print("recovered from error") })
print("Done")
```

**This is how `tryCatchLog` works internally!**



## Usability?

**Do you really want to use that much code in your R script at every place
where you have to catch errors and conditions?**

See the the next slides on how the package `tryCatchLog` could make your life easier!



# Solution: The `tryCatchLog` package

## `tryLog` with an error

```{r, results = 'hide', message = FALSE, echo = FALSE}
library(tryCatchLog)   # load the package to avoid startup messages in the results later
```

Errors are logged but the execution continues after the `tryLog` call:

```{r, eval = FALSE, warning=F}
library(tryCatchLog)
f <- function(value) {
  print("begin")
  log(value)            # negative number -> warning; string -> error
  print("end")
}
tryLog(f("not a number"))  
print("Errors don't stop me!")
```

```{r, eval = FALSE}
## [1] "begin"
## ERROR [2016-12-06 21:44:21] non-numeric argument to mathematical function
## Compact call stack:
##   1 test.R#7: tryLog(f("not a number"))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .handleSimpleError(function (e) 
## ...
## [1] "Errors don't stop me!"
```



## `tryLog` with a warning



`tryLog` traps conditions and log them onto console or into a file (depending of the settings of
the logging framework `futile.logger` that is used internally):

```{r, eval = FALSE, warning=F}
library(tryCatchLog)
f <- function(value) {
  print("begin")
  log(value)            # negative number -> warning; string -> error
  print("end")
}
tryLog(f(-1))  
```

```{r eval = FALSE}
## [1] "begin"
## WARN [2016-12-06 21:33:41] NaNs produced
## Compact call stack:
##   1 test.R#7: tryLog(f(-1))
##   2 tryCatchLog.R#345: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
##   3 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
##   4 test.R#4: .signalSimpleWarning("NaNs produced", quote(log(value)))
...
## [1] "end"
```



## `tryCatchLog` to recover from errors

Use `tryCatchLog` to also establish an error handler:

```{r, eval = FALSE}
library(tryCatchLog)

tryCatchLog(read.csv("server.log"),
            error = function(e) { send.email("admin@home.de", e)
})
```

```{r eval = FALSE}
## ERROR [2016-12-06 22:13:05] cannot open the connection
## Compact call stack:
##   1 test.R#3: tryCatchLog(read.csv("server.log"), error = function(e) {
##   2 tryCatchLog.R#259: tryCatch(withCallingHandlers(expr, error = function(e) {
...
```

**Note:** `send.email` is a dummy function for demonstration purposes!



## Change logging behaviour

To log to a file instead of the console or to change the logging level you call the usual `futile.logger` functions:

```{r eval = FALSE}
  library(futile.logger)
  flog.appender(appender.file("app.log"))
  flog.threshold(ERROR)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL
  try(log(-1))             # the warning will not be logged!
```

For more details about `futile.logger` see:

https://cran.r-project.org/package=futile.logger



# Post-mortem analysis



## From interactive debugging...

Interactive debugging is very difficult in case of

- errors that are not (easily) reproducible.
- long running code that produces an error at the end
- batch jobs running on a server



## ... to post-mortem analysis

**Post-mortem analysis**: In case of an error create a dump file with all variables of the global environment (workspace)
and all environments of each called function (via `dump.frames`) so that you can

- load the dump file into a new R session after the script has stopped the execution ("post-mortem") and
- examine the call stack and variable values ("analysis")

to find out the reason for the error.



## Create a dump file with `tryCatchLog`

`tryCatchLog` supports post-mortem analysis by creating dump files in case of errors:

```{r eval = FALSE}
library(tryCatchLog)
f <- function(value) {
  log(value)
}
a <- "100"
tryLog(f(a), dump.errors.to.file = TRUE)
```

```{r eval = FALSE}
ERROR [2016-12-12 22:29:52] non-numeric argument to mathematical function
Call stack environments dumped into file: dump_20161212_222952.rda
Compact call stack:
  1 source("~/R_trainings/tryCatchLog/src/test.R")
  2 test.R#6: tryLog(f(a), dump.errors.to.file = TRUE)
  3 tryCatchLog.R#348: tryCatchLog(expr = expr, dump.errors.to.file = dump.errors.to.file, error = function(e) {
  4 tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
  5 test.R#3: .handleSimpleError(function (e)
  ...
```



## Start post-mortem debugging

Open a new R session and start the post-mortem analysis of the error:

```{r eval = FALSE}
load("dump_20161212_222952.rda")    # load the dump into the global environment
debugger(last.dump)                 # start the post-mortem analysis
```

```{r eval = FALSE}
Message:  non-numeric argument to mathematical functionAvailable environments had calls:
1: source("test.R")
...
5: test.R#6: tryLog(f(a), dump.errors.to.file = TRUE)
6: tryCatchLog.R#348: tryCatchLog(expr = expr, dump.errors.to.file = dump.erro
7: tryCatchLog.R#262: tryCatch(withCallingHandlers(expr, error = function(e) {
...
12: f(a)
13: test.R#3: .handleSimpleError(function (e) 
14: h(simpleError(msg, call))

Enter an environment number, or 0 to exit  
Selection: <Cursor is waiting for your input here>
```

Function call 13 shows: The error was thrown in the file `test.R` at line #3: `log(value)`



## Post-mortem debugging: Examine an environment

Switch into the environment of the function call 12 in which the error occured.

The environment of function call 12 contains all variables visible within the function:

```{r eval = FALSE}
Enter an environment number, or 0 to exit  
Selection: 12
Browsing in the environment with call:
   f(a)
Called from: debugger.look(ind)
Browse[1]> ls()
[1] "value"
Browse[1]> value
[1] "100"
Browse[1]> typeof(value)
[1] "character"
Browse[1]> 
```

By looking at the value and data type of the variable `value` it is easy to identify the reason for error.

*You can exit the debugger with "Q" (or "f" followed by "0") now.*



## Post-mortem debugging: Limitations

R dump files (created with `save.image`) do **not** contain the packages
loaded when the dump file was created and a dump loaded into memory does
**not** use exactly the same search path to find objects during post-mortem debugging.

This means:

- the program state is not exactly reproducible if objects are stored within a package namespace
- you cannot step through your source code in a reproducible way after loading the image
  if your source code calls functions of non-default packages

For more details see: https://github.com/aryoda/tryCatchLog/issues/12



# `tryCatchLog` functions reference



## tryCatchLog()

Function signature:
```{r eval = FALSE}
tryCatchLog(expr,
  error = getOption("error", default = stop),
  finally = NULL,
  dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE),
  silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
  silent.messages = getOption("tryCatchLog.silent.messages", FALSE))
```

This function evaluates the expression in `expr` and calls the error handler function `error` in case of an error condition.
The function in `finally` is then always evaluated at the end.
Conditions (errors, warnings and messages) are logged with the function call stack (including file names and line numbers).
Warnings and messages can be "silenced" (only logged but not propagated to the caller) using the `silent.*` parameters.

The default values of some parameters can be set globally via options to avoid repeating the same
parameter values and to support an easy reconfiguration for all calls.



## tryLog()

Function signature:
```{r eval = FALSE}
tryLog(expr,
  dump.errors.to.file = getOption("tryCatchLog.dump.errors.to.file", FALSE),
  silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
  silent.messages = getOption("tryCatchLog.silent.messages", FALSE))
```

This function is a short version of `tryCatchLog()`
that traps any errors that occur during the evaluation of the expression `expr`
without stopping the execution of the script (similar to `try` in R).
Errors, warnings and messages are logged.

In contrast to `tryCatchLog()` it returns but does not stop in case of an error
and therefor does not have the error and finally parameters to pass in custom handler functions.

The default values of some parameters can be set globally via options to avoid repeating the same
parameter values and to support an easy reconfiguration for all calls.



## Change global options of `tryCatchLog`

You can change the default values of many options globally by initalizing them once in your code
to reduce lengthy function calls later, e. g.

```{r results = "hide"}
# Initialize your own default values globally for tryLog and tryCatchLog
options(tryCatchLog.dump.errors.to.file = FALSE)
options(tryCatchLog.silent.messages     = TRUE)
options(tryCatchLog.silent.warnings     = TRUE)

test <- function() {
  message("hello")
  warning("a warning")
}

# Use your own default values by ommiting those parameters...
tryLog(test())

# .. instead of using the longer version
tryLog(test(), silent.warnings = TRUE, silent.messages = TRUE, dump.errors.to.file = FALSE)
```




## TODO: `tryCatchLog` Best Practices

0. Use options to change the default values globally

1. Avoid that too many dump files filling your disk space

    you should omit the \code{dump.errors.to.file}
    parameter and instead set its default value using the option \code{tryCatchLog.dump.errors.to.file} in your
    \link{.Rprofile} file instead (or in a startup R script that sources your actual script).
    In case of an error (that you can reproduce) you set the option to \code{TRUE} and re-run your script.
    Then you are able to examine the program state that led to the error by debugging the saved dump file.

1. Enable source code references (source file names and line numbers)} in the stack traces

    you must set this option before executing your code:\cr
    \code{options(keep.source = TRUE)}

1. Execute your code as R batch file

    with \code{\link{Rscript}} using this shell script command}:\cr
    \code{Rscript -e "options(keep.source = TRUE); source('my_main_function.R')"}


- Options zum gezielten temporären Aktivieren von Funktionalitäten
- Anwendungs-Szenarios interaktiv (mit/ohne Benutzer-Interaktion) vs. Batch
  -> in einem eigenen Kapitel?!




## TODO Summary + advantages - Prüfen, ob das alles erwähnt wird...

Probleme bei klassischen error handling:

- sys.calls enthält keine source code references -> limitedLabels
- sys.calls (genau wie traceback) enthält auch viele R-interne Funktionsaufrufe,
  die für die Fehlersuche nicht hilfreich sind -> gilt aber auch für tryCatchLog!
- Kombi aus withCallingHandlers und tryCatch ist umständlich und lang

Vorteile von tryCatchLog

+ source code references
+ compact call stack (if available) 
+ Top-Feature: post-mortem analysis!
+ also logs conditions from used packages

